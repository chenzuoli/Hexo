---
title: 上海面试总结
date: 2020-06-10 06:19:31
tags: [数据仓库]
categories: 数据仓库
notebook: 数据仓库
---

来上海面试，来看看面试的这几家公司问的问题。

<!-- more -->

# 一、叽里呱啦
## 1.sql解决数据倾斜问题
|     关键词     |   情形   |   后果   |
| :----------: | :------: | :------: |
| join  | 其中一个表较小，但是key集中 | 分发到某一个或几个reduce上的数据量远超于平均值  |
| join  | 大表与大表，但是分桶的判断是0值或空值过多 | 这些0值或空值都由一个reduce处理非常慢 |
| group by  | group by 维度过小，某值得数量过多 | 处理某值得reduce非常耗时 |
| count distinct | 某值得数量过多 | 处理此特殊值的reduce非常耗时 |

原因：
1）key分布不均匀
2）业务数据本身特性
3）建表时考虑不周
4）某些sql语句本身带有数据倾斜

解决方案：
1）参数调节
hive.map.aggr=true;
map端分聚合，相当于combiner
hive.groupby.skewindata=true;
有数据倾斜的时候进行负载均衡，当设定为true后，生成的执行计划有2个MR Job，第一个mr job中，map的输出结果会随机分配到reduce中，每个reduce做部分聚合操作，并输出结果，这样处理的结果是相同的group by key，会分配到不同的reduce中；第二个mr job，再根据第一个job得到的结果group by key进行reduce操作。

2）sql语句调节
a.大表join小表
hive.convert.join=true;
map端join操作让小的维表先进内存，在map端完成reduce操作，再reduce；

b.大表join大表
先对大表中的key做一个值分布，看看
把空值的key变成一个随机数，把倾斜的数据分发到不同的reduce中，由于null值关联不上，不影响最后结果

c.count distinct大量相同特殊值
将异常值单独处理，过滤调

d.group by 维度过小
sum() group by 替换count(distinct)

e.特殊情况特殊处理
在业务逻辑优化效果不大的情况下，有些时候是可以将特殊数据单独拿出来特殊处理，然后再union回去。


3）空值产生的数据倾斜
空值不参与关联
```
select * from log a
join users b
  on a.user_id is not null
  and a.user_id = b.user_id
union all
select * from log a
  where a.user_id is null;
```
赋予空值新的key
```
select *
  from log a
  left outer join users b
  on case when a.user_id is null then concat(‘hive’,rand() ) else a.user_id end = b.user_id;
```
方法二比方法一好：IO少，job数也变少了。方法一种log读2次，2个job，方法二log读一次，1个job

4）不同类型值关联产生数据倾斜
场景：user表user_id为int类型，log表中user_id为string类型，当2个表按照user_id进行join时，默认的hash操作会按照int类型的id进行分配，这样会导致所有string类型的user_id记录都在同一个reducer中。
解决办法：将数字类型转化成字符串类型
```
select * from users a
  left outer join logs b
  on a.usr_id = cast(b.user_id as string)
```

5）小表不大不小，怎么用map join解决数据倾斜
使用mapjoin 解决小表join大表出现的数据倾斜情况，但是如果小表不大不小，导致join的时候出现异常或者bug，这时就需要特别梳理。
```
select * from log a
  left outer join users b
  on a.user_id = b.user_id;
```
如果小表user表有600w记录，将user表分发到所有map端内存中也是不小的开支。这时，可以先进行筛选一遍user表，假如log表中的user_id有上百万个，当天的pv，uv，click pv不会太多，所以可以筛选掉大部分的user_id；
```
select * from log a
  left outer join (
    select  d.*
      from ( select distinct user_id from log ) c
      join users d
      on c.user_id = d.user_id
    ) b
  on a.user_id = b.user_id;
```


## 2.hive sql解析成MapReduce过程
AST tree -> Query Block -> Operator tree -> Map Reduce
a.Antlr定义SQL的语法规则，完成SQL词法，语法解析，将SQL转化为抽象语法树AST Tree
b.遍历AST Tree，抽象出查询的基本组成单元QueryBlock
c.遍历QueryBlock，翻译为执行操作树OperatorTree
d.逻辑层优化器进行OperatorTree变换，合并不必要的ReduceSinkOperator，减少shuffle数据量
e.遍历OperatorTree，翻译为MapReduce任务
f.物理层优化器进行MapReduce任务的变换，生成最终的执行计划

## 3.怎么理解数据开发与数据仓库
数据开发基于数据仓库，在仓库的基础上做分析、挖掘
数据仓库存储、管理数据

## 4.怎么理解在线教育

## 5.对数据工程师的理解

## 6.Hive行列互转
1）列转行
concat_ws和collect_set、collect_list
2）行转列
lateral view explode和split

## 7.事实表分几类
从粒度划分
1）事务事实表
    在某个时间点上的一个事件，比如：下单、付款、退款等事实，
2）周期快照事实表
    某段时间内的数据进行分析，比如每天、月、周、季度、年。
3）累积快照事实表
    具有确定的开始和结束日期，时间段不固定，并且记录关键事件或者过程的里程碑。
    累积快照事实表和周期快照事实表有些相似之处，它们存储的都是事务数据的快照信息。但是它们之间也有着很大的不同，周期快照事实表记录的确定的周期的数据，而累积快照事实表记录的不确定的周期的数据。


从用途来区分
1）原子事实表
2）聚集事实表
    某些维度上的原子事实表，也可以做一定程度的汇总
3）合并事实表
    从多个事实表来，合并到一起组成新的事实表，可以做一定程度的汇总


## 8.维表分几类
桥接表
缓慢变化维表

## 9.领域建模的事实表和维度建模的事实表有什么区别？

## 10.kafka多分区情况下如何保证有序
同一key发送到同一partition

## 11.kafka ack机制
1）ack=1(默认)，producer生产消息，kafka只要一个副本成功写入就反馈成功消息给producer，这个副本一定要是leader副本
2）ack=0，producer只推送一次消息
3）ack=-1，kafka全部副本复制完成才会反馈成功消息给producer。

## 12.lucene倒排索引的原理
一般我们查询关系型表的时候，指定where条件，某个字段等于某个值，这是正排索引，通过指定值去找。
倒排索引是文章内容进行分词后，得到一个字典，这个字典是一个一个词组成，还会有频率文件，位置文件，当我们想查询某个词时，就找到了这个词的频率，在那些文件里面，直接定位文档。

# 二、鲲驰
## 1.设计的维度有哪些？
会员等级，地域，年龄，性别，订单，服务，时间

## 2.日活月活多少？
总用户100万，日活17万，月活